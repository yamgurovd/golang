# Switch

Предположим, мы захотели написать программу, которая печатала бы английские названия для чисел. С использованием того,
что мы знали до текущего момента, это могло бы выглядеть примерно так:

```go
if i == 0 {
fmt.Println("Zero")
} else if i == 1 {
fmt.Println("One")
} else if i == 2 {
fmt.Println("Two")
} else if i == 3 {
fmt.Println("Three")
} else if i == 4 {
fmt.Println("Four")
} else if i == 5 {
fmt.Println("Five")
}
```

Но эта запись слишком громоздка. `Go` содержит в себе другой оператор, позволяющий делать такие вещи проще: оператор
`switch` (переключатель). С ним программа может выглядеть так:

```go
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```

Переключатель начинается с ключевого слова `switch`, за которым следует выражение (`в нашем случае i`) и серия возможных
значений (`case`). Значение выражения по очереди сравнивается с выражениями, следующими после ключевого слова case. Если
они оказываются равны, то выполняется действие, описанное после `:`.

Как и условия, обход возможных значений осуществляется сверху вниз, и выбирается первое значение, которое сошлось с
выражением. Переключатель также поддерживает действие по умолчанию, которое будет выполнено в случае, если не подошло ни
одно из возможных значений (`напоминает else в операторе if`).

В `switch` можно использовать любой тип данных.

Стоит дополнить, что:

1. В `Go` код после case выполняется до следующего `case`, и нет нужды каждый case-блок заканчивать ключевым словом `break` (
   данная особенность добавлена в язык специально, чтобы уменьшить количество ошибок в `switch`-блоках). Если в текущем
   case написать `fallthrough`, то тело следующего case выполнится вне зависимости от того истинно ли его (следующего
   `case`) условие:

```go
v := 42
switch v {
case 100:
fmt.Println(100)
fallthrough
case 42:
fmt.Println(42)
fallthrough
case 1:
fmt.Println(1)
fallthrough
default:
fmt.Println("default")
}
// Вывод:
// 42
// 1
// default
```

2. Существует специальная форма `switch`, допускающая использование произвольных условий в каждом case-блоке:

```go
var c uint32
fmt.Scan(&c)
switch {
case 1 <= c && c <= 9:
fmt.Println("от 1 до 9")
case 100 <= c && c <= 250:
fmt.Println("от 100 до 250")
case 1000 <= c && c <= 6000:
fmt.Println("от 1000 до 6000")
}
```

То есть, сразу после `switch` "переключатель" не нужен, а после каждого `case` идет выражение с произвольным условием.